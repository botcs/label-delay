<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modeling Label Delay in Continual Learning</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond&display=swap" rel="stylesheet">

    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <!-- <script type="text/javascript" async
        src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script> -->
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <style>
        #viz {
            border: 2px solid black;
        }
        #primary-content {
            margin: 0 auto;
            max-width: 1000px;
            padding: 30px;
        }
        .image-container {
            overflow: hidden;
            position: relative;
        }
        .image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .grayscale {
            filter: url(#grayscale);
            filter: grayscale(100%);
        }
        .button-rect {
            fill: #ccc;
        }

        .button-rect:hover {
            fill: #aaa; /* Darker shade for hover effect */
            cursor: pointer;
        }

        .button-text {
            pointer-events: none; /* This makes sure text doesn't interfere with the hover effect */
        }

        .fig{
            /* margin: 0 auto; */
            max-width: 1000px;
            /* padding-top: 30px; */
            text-align: center;
        }
        .bottom-dashed-border {
           border-bottom: 2px dashed #000;  /* 2px width, dashed style, and black color */
        }
        .top-dashed-border {
           border-top: 2px dashed #000;  /* 2px width, dashed style, and black color */
        }
        body {
            font-family: 'EB Garamond', serif;
            font-size: 22px;
            text-align: justify;
        }

        section {
            margin: 0 auto;
            max-width: 1000px;
            padding-top: 20px;
            text-align: justify;
        }

        svg {
            border: 2px solid gray;
        }
    </style>
</head>

<body>
    <div id="primary-content">
        <center>
            <h1>Modeling Label Delay in Continual Learning</h1>
            <h4>Botos Csaba<sup>12</sup>*,  Wenxuan Zhang,<sup>3</sup>*, Matthias Müller<sup>2</sup>, Ser-Nam Lim<sup>4</sup>,  Mohamed Elhoseiny<sup>3</sup>,  Philip Torr<sup>1</sup>,  Adel Bibi<sup>1</sup></h4>
            <h5><sup>1</sup>University of Oxford, <sup>2</sup>Intel, <sup>3</sup>KAUST, <sup>4</sup>Facebook AI Research, * Equal contribution</h5>

            <div id="fig1" class="fig">
                <svg width="1000" height="500" id="fig1-svg">
                    <defs id="fig1-defs">
                        <filter id="grayscale">
                            <feColorMatrix id="matrix" type="saturate" values="0"></feColorMatrix>
                        </filter>
                        <marker
                            id="arrow"
                            markerUnits="strokeWidth"
                            markerWidth="12"
                            markerHeight="12"
                            viewBox="0 0 12 12"
                            refX="6"
                            refY="6"
                            orient="auto">
                            <path d="M2,2 L10,6 L2,10 L6,6 L2,2" style="fill: rgb(0, 0, 0);"></path>
                        </marker>
                    </defs>
                </svg>
                <div style="text-align:justify; margin-top:20px">
                Our proposed Continual Learning setting considering <b>Label Delay</b> allows us to model a wide range of real-world applications where new raw data is revealed significantly sooner by the data stream $\mathcal{S}_{\mathcal{X}}$ than the annotation process $\mathcal{S}_{\mathcal{Y}}$ can provide the corresponding labels. The main objective is to maximize the accuracy on the newest <b>Eval</b> data using both the samples that have already received their label (in colour) and the more recent samples that are yet to be labeled (in gray).
                </div>
                <!-- The goal is to learn a model that can perform well on a sequence of tasks, where the labels for each task are delayed by a fixed number of steps. We propose a simple yet effective approach to model label delay, which we call <b>Delayed Labels</b>. We show that our approach can be used to model a wide range of label delay distributions, and that it can be easily integrated into existing continual learning methods. We evaluate our approach on a variety of continual learning benchmarks, and show that it consistently outperforms existing methods. -->
            </div>
            
            <section>
                <h2 style="text-align:left;">Where does label delay come from?</h2>
                In many real world scenario, the time between making predictions and the feedback can be vastly different due to the inherent nature of the task.
                Consider the following three examples:
                In medical applications, the predicted post-operation recovery time of the patient is one of the most important metrics, yet the official recovery time is only established during follow-up visits.
                In investment banking, the time it takes to receive the results of a trade can be significantly longer than the time it takes to execute the trade itself.
                In the world of copyright claims, an automated trigger mechanism can prevent fraudulent usage of the content sharing platform, however the actual evaluation of each case by the owners is often significantly delayed.
            <div id="fig2" class="fig" style="text-align:center; margin-top:20px">
                <svg width="700" height="280" id="fig2-svg">
                    <defs id="fig2-defs">
                        <filter id="grayscale">
                            <feColorMatrix id="matrix" type="saturate" values="0"></feColorMatrix>
                        </filter>
                        <marker
                            id="arrow"
                            markerUnits="strokeWidth"
                            markerWidth="12"
                            markerHeight="12"
                            viewBox="0 0 12 12"
                            refX="6"
                            refY="6"
                            orient="auto">
                            <path d="M2,2 L10,6 L2,10 L6,6 L2,2" style="fill: rgb(0, 0, 0);"></path>
                        </marker>
                    </defs>
                </svg>
            </div>
            <div id="fig3" class="fig">
                <svg width="700" height="280" id="fig3-svg">
                    <defs id="fig3-defs">
                        <filter id="grayscale">
                            <feColorMatrix id="matrix" type="saturate" values="0"></feColorMatrix>
                        </filter>
                        <marker
                            id="arrow"
                            markerUnits="strokeWidth"
                            markerWidth="12"
                            markerHeight="12"
                            viewBox="0 0 12 12"
                            refX="6"
                            refY="6"
                            orient="auto">
                            <path d="M2,2 L10,6 L2,10 L6,6 L2,2" style="fill: rgb(0, 0, 0);"></path>
                        </marker>
                    </defs>
                </svg>
            </div>
            <div id="fig4" class="fig">
                <svg width="700" height="280" id="fig4-svg">
                    <defs id="fig4-defs">
                        <filter id="grayscale">
                            <feColorMatrix id="matrix" type="saturate" values="0"></feColorMatrix>
                        </filter>
                        <marker
                            id="arrow"
                            markerUnits="strokeWidth"
                            markerWidth="12"
                            markerHeight="12"
                            viewBox="0 0 12 12"
                            refX="6"
                            refY="6"
                            orient="auto">
                            <path d="M2,2 L10,6 L2,10 L6,6 L2,2" style="fill: rgb(0, 0, 0);"></path>
                        </marker>
                    </defs>
                </svg>
            </div>
            As one can see in the above examples, although the emergent problem of label delay is present across different applications, the root cause stems from entirely different sources.
            While the real world applications are heavily impacted by the phenomenon, the diversity of the various scenarios makes it difficult to find common patterns that can be used to address the problem of label delay.
            A few challenges that one might find when trying to model label delays in real-world applications are:
            <ul style="margin-left:40px">
                <li>The data distribution is evolving over time</li>
                <li>The delay factor cannot be influenced for analysis</li>
                <li>The delay impacts the model in unknown ways</li>
            </ul>
            </section>
            <section>
                <h2 style="text-align:left;">Our proposal</h2>
                <div style="text-align:justify; margin-top:20px">
                    We propose a new Continual Learning setting, in which we show how does label delay impact the learning process.
                    We consider the naïve solution of ignoring the most recently collected data and only using the samples that have already received their label and compare it to the ideal case where the labels are immediately available for all samples.
                    We provide an extensive list of experiments (amounting to over 25k GPU hours) of trying to recover the performance of the ideal case by using the samples before their corresponding labels become available.

                    <div style="margin-top:20px; width:100%; text-align: center;">
                        <img src="fig-delay-ablation-CLOC.svg" style="width:35%; margin-top:20px; display: inline-block; vertical-align: middle;">
                        <img src="fig-delay-ablation-CGLM.svg" style="width:35%; margin-top:20px; display: inline-block; vertical-align: middle;">
                    </div>

                    We use two large-scale datasets to evaluate our approach: <b>Continual Localization (CLOC - 40M samples)</b> and <b>Continual Google Landmarks (CGLM - 0.5M samples)</b>.
                    As one can see in the above figures, there is a growing gap between the performance of the ideal case and the naïve solution as the delay increases.
                    More importantly, we show that on different datasets the impact of the delay differs significantly, which highlights the importance of modeling label delay.
                </div>
            </section>
            <section>
                <h2 style="text-align:left;">How to overcome label delay?</h2>
                Even though one might not be able to influence the delay factor, we show that it is possible to recover the performance of the ideal case by using the samples before their corresponding labels become available.
                There are two main challenges that one needs to overcome in order to achieve this:
                <!-- <ul style="margin-left:40px">
                    <li>How to use the unlabeled samples to improve the model?</li>
                    <li>How to keep the solution computationally efficient?</li>
                </ul> -->
                1) using the unlabeled samples to improve the model
                2) keeping the solution computationally efficient
                To address these challenges our experiment allows the continual learning models to use the unlabeled samples, while normalizing the computational cost of the model to be the same as the naïve solution.
                <div id="fig5" class="fig" style="margin-top:20px; margin-bottom:20px">
                    <svg width="700" height="400" id="fig5-svg">
                        <defs id="fig5-defs">
                            <marker
                                id="arrow"
                                markerUnits="strokeWidth"
                                markerWidth="12"
                                markerHeight="12"
                                viewBox="0 0 12 12"
                                refX="6"
                                refY="6"
                                orient="auto">
                                <path d="M2,2 L10,6 L2,10 L6,6 L2,2" style="fill: rgb(0, 0, 0);"></path>
                            </marker>
                        </defs>
                    </svg>
                </div>
                This allows us to compare the performance of various methods that extend the naïve solution to use the unlabeled samples.
                Under such a setting, we can use the naïve solution as the lower bound and the ideal case as the upper bound, while keeping the computational cost $\mathcal{C}$ of the model the same.
                In our work, we compare the performance of various families of methods, such as Test-Time Adaptation (TTA) and Self-Supervised Learning (SSL) and propose a new, more efficient approach fine-tailored to the problem of label delay.

            <div style="margin-top:20px; width:100%; text-align: center;">
                <img src="fig-unsupervised.svg" style="width:85%; margin-top:20px; display: inline-block; vertical-align: middle; horizontal-align: middle;">
            </div>
            </section>
        </center>
    </div>

    <script src="fig1.js"></script>
    <script src="fig2.js"></script>
    <script src="fig3.js"></script>
    <script src="fig4.js"></script>
    <script src="fig5.js"></script>




</body>

</html>
