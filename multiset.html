<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiset Permutation Visualization</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond&display=swap" rel="stylesheet">
    
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        body {
            font-family: 'EB Garamond', serif;
            font-size: 22; /* Make sure to add 'px' or another unit */
            text-align: justify;
            max-width: 800px;
            margin: auto; /* Centers the content */
            /* padding: 0 20; Optional: Adds some padding on the sides */
        }
        h1 {
            font-size: 50px;
            text-align: center;
            margin-bottom: 0;
        }
        p {
            font-family: 'EB Garamond', serif;
            font-size: 18px;
            text-align: justify;
            margin-top: 5;
        }
        a {
            color: black;
        }
        #visualization {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .circle {
            fill: transparent;
            stroke: black;
        }

        .boat {
            cursor: pointer;
            stroke: black;
            stroke-width: 2px;
        }

        .boat.red {
            fill: red;
        }

        .boat.orange {
            fill: orange;
        }

        .boat.purple {
            fill: purple;
        }

        .boat.selected {
            stroke: black;
            stroke-width: 2px;
        }


        .button {
            cursor: pointer;
        }

        .connector {
            fill: none;
            stroke: black;
            stroke-width: 2px;
            opacity: 1;
        }

        button {
            /* Basic styling */
            background-color: white;   /* White frontground */
            color: black;              /* Text color */
            border: 3px solid black;   /* Wide black border */
            padding: 10px 20px;        /* Padding around the text */
            font-size: 16px;           /* Font size */
            cursor: pointer;           /* Cursor changes to a pointer on hover */
            border-radius: 15px;       /* Rounded corners */
            transition: all 0.3s;      /* Smooth transition for hover effects */
            text-align: center;        /* Center the text */
            text-decoration: none;     /* Remove underline from links, if applicable */
            display: inline-block;     /* Allows setting dimensions and alignment */
        }

        button:hover {
            background-color: #ffb9b9; /* Pastel red frontground on hover */
            border-color: transparent;
        }

        button:active {
            background-color: #ff7b7b; /* Darker red frontground on click */
            border-color: transparent;
        }

    </style>
</head>
<body>
    <!-- write Wo in red and Sch in orange -->
    <h1>
        <span style="color: rgb(157, 0, 0);">Wo</span>lfson <span style="color: rgb(189, 123, 1);">Sch</span>eduler
        <!-- Wolfson Scheduler -->
    </h1>
    <p style="text-align: center;">
        by <a href="https://botcs.github.io/academic/" style="text-decoration: none;">Botos Csabi</a>
        </br>
        [<a href="https://github.com/botcs/wcbc-autosched">code</a>]
        [<a href="https://docs.google.com/spreadsheets/d/1Lp2s6J7ZfjsjSEf9f0xAunuB1ehKTM6zPfsTSaKRQSA/edit#gid=0>">demo</a>]
    </p>

    <div id="visualization">
    <svg width="800" height="250" id="fig1"></svg>
    </div>

    <p>
        The Wolfson Scheduler (WoSch) is a tool developed to help the colleges organize rowing outings. 
        WoSch helps by drafting the weekly schedule of outings, accommodating the preferences and skill levels of the rowers,
        and the scheduling policies of the coaches and captains.
        This project is open-source and available on <a href="https://github.com/botcs/wcbc-autosched">GitHub</a>.
        The <a href="https://docs.google.com/spreadsheets/d/1Lp2s6J7ZfjsjSEf9f0xAunuB1ehKTM6zPfsTSaKRQSA/edit#gid=0>">demo</a> 
        works through the interface of Google Sheets,
        meaning that no installation or programming knowledge is required to use it.
    </p>

    <script>
        function delay(time) {
            return new Promise(resolve => setTimeout(resolve, time));
        }


        function multisetPermutation(setSizes) {
            // Generate the multiset
            let multiset = [];
            let currentNumber = 0;
            for (let size of setSizes) {
                for (let i = 0; i < size; i++) {
                    multiset.push(currentNumber);
                }
                currentNumber++;
            }

            // Shuffle the multiset to create a permutation
            for (trial = 0; trial < 1; trial++) {
                for (let i = multiset.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [multiset[i], multiset[j]] = [multiset[j], multiset[i]];
                }
            }

            return multiset;
        }

        // Function to create the path for the curve
        function createVertConnector(fromP, toP) {
            fromP.x = parseInt(fromP.x);
            fromP.y = parseInt(fromP.y);
            toP.x = parseInt(toP.x);
            toP.y = parseInt(toP.y);
            const path = d3.path();
            path.moveTo(fromP.x, fromP.y);
            sharpness = 0.5;
            const control1X = fromP.x;
            const control1Y = fromP.y + sharpness * (toP.y - fromP.y);
            const control2X = toP.x;
            const control2Y = toP.y - sharpness * (toP.y - fromP.y);

            // path.quadraticCurveTo(controlX, controlY, toP.x, toP.y);
            path.bezierCurveTo(control1X, control1Y, control2X, control2Y, toP.x, toP.y);
            return path.toString();
        }

        function createHorConnector(fromP, toP) {
            fromP.x = parseInt(fromP.x);
            fromP.y = parseInt(fromP.y);
            toP.x = parseInt(toP.x);
            toP.y = parseInt(toP.y);
            const path = d3.path();
            path.moveTo(fromP.x, fromP.y);
            sharpness = 0.5;
            const control1X = fromP.x + sharpness * (toP.x - fromP.x);
            const control1Y = fromP.y;
            const control2X = toP.x - sharpness * (toP.x - fromP.x);
            const control2Y = toP.y;
            path.bezierCurveTo(control1X, control1Y, control2X, control2Y, toP.x, toP.y);
            return path.toString();
        }



        function drawMain(){

            const width = 800;
            const height = 300;
            const svg = d3.select('#fig1')
            const num_rowers = 20;

            // boat data
            const boatData = [
                { value: 8, x: 170, y: 50, color: 'red' },
                { value: 4, x: 370, y: 50, color: 'orange' },
                { value: 4, x: 570, y: 50, color: 'purple' }
            ];
            const num_seats = boatData.reduce((acc, curr) => acc + curr.value, 0);
            const num_reserves = num_rowers - num_seats;

            // Create boats
            let boatShape = "M16.25,8a5.73,5.73,0,0,0,3.2-1h0A1,1,0,0,1,21,7.86v1.2A4,4,0,0,1,17.06,13H6.94A4,4,0,0,1,3,9.06V7.86A1,1,0,0,1,4.55,7h0a5.73,5.73,0,0,0,3.2,1ZM16,16.79,7.78,5m8.58,14-.57-.82A1,1,0,0,1,16,16.79h0a1,1,0,0,1,1.4.24l.57.82Z";
            const boatShapeScale = 3;
            const boats = svg.selectAll('.boat')
                .data(boatData)
                .enter().append('path')
                .attr('class', d => `boat ${d.color}`)
                // load d from boat.svg
                .attr('d', boatShape)
                .attr('transform', d => `translate(${d.x}, ${d.y}) scale(${boatShapeScale})`)
                .attr('connect_x', d => d.x + 16*boatShapeScale)
                .attr('connect_y', d => d.y + 20*boatShapeScale)
                .on('click', function(selectedData) {
                    svg.selectAll('.boat').classed('selected', false); // Deselect all
                    d3.select(this).classed('selected', true); // Select the clicked one
                });

            
            // Add text to boats
            svg.selectAll('.boat-text')
                .data(boatData)
                .enter().append('text')
                .attr('class', 'boat-text')
                .attr('x', d => d.x)
                .attr('y', d => d.y + 100)
                .text(d => d.value)
                .attr('text-anchor', 'middle')
                .attr('fill', 'white');


            // Create 20 circles
            svg.selectAll('.circle')
                .data(new Array(num_rowers))
                .enter().append('circle')
                .attr('class', 'circle')
                .attr('cx', (d, i) => 50 + i * 35)
                .attr('cy', 200)
                .attr('r', 15)
                .style('stroke-width', 2)
                .attr('connect_x', (d, i) => 50 + i * 35)
                .attr('connect_y', 200-15);

            // For each circle, add a path to connect it to the boat
            svg.selectAll('.connector')
                .data(new Array(num_rowers))
                .enter().append('path')
                .attr('class', 'connector')
                .attr('d', d => `M 0 0 l 0 0 z`)
                .style('opacity', 0);
                
            
            

            // Update circles to respond to mouse events
            svg.selectAll('.circle')
                .on('mouseover', function(event, d) {
                    const selectedboat = svg.select('.boat.selected');
                    if (!selectedboat.empty()) {
                        const data = selectedboat.data()[0];
                        const circle_radius = parseInt(d3.select(this).attr('r'));
                        const circlePos = { 
                            x: d3.select(this).attr('cx'), 
                            y: d3.select(this).attr('cy')-circle_radius};
                        const boatPos = { x: data.x, y: data.y + 60 }; 
                        curve.attr('d', createVertConnector(boatPos, circlePos))
                            .transition()
                            .duration(500)
                            .style('opacity', 1);
                    }
                })
                .on('mouseout', function() {
                    curve.transition()
                        .duration(500)
                        .style('opacity', 0);
                });

            function connectRowerToBoat(rowerIdx, boatIdx) {
                const rower = svg.selectAll('.circle').filter((d, i) => i === rowerIdx);
                const curve = svg.selectAll('.connector').filter((d, i) => i === rowerIdx);
                const boat = svg.selectAll('.boat').filter((d, i) => i === boatIdx);
                const color = boat.data()[0].color;
                
                const boat_x = parseInt(boat.attr('connect_x'));
                const boat_y = parseInt(boat.attr('connect_y'));
                const boatPos = { x: boat_x, y: boat_y };

                const rower_x = parseInt(rower.attr('connect_x'));
                const rower_y = parseInt(rower.attr('connect_y'));
                const rower_pos = { x: rower_x, y: rower_y };

                curve.attr('d', createVertConnector(boatPos, rower_pos))
                    .transition()
                    .duration(500)
                    .style('stroke', color)
                    .style('opacity', .6);

                rower.transition()
                    .duration(500)
                    .style('stroke-width', 4)
                    .style('stroke', color);
            }

            let finishedDrawing = true;
            async function resetConnections() {

                svg.selectAll('.connector')
                    .transition()
                    .duration(500)
                    .style('opacity', 0);
                
                svg.selectAll('.circle')
                    .transition()
                    .duration(500)
                    .style('stroke-width', 2)
                    .style('stroke', 'black');
                    
                await delay(600);    
            }

            async function drawConnections() {
                    if (!finishedDrawing){
                        return;
                    };
                    finishedDrawing = false;
                    await resetConnections();
                    
                    boatSizes = boatData.map(d => d.value);
                    boatSizes.push(num_reserves);
                    const newMultiset = multisetPermutation(boatSizes);
                    // draw boat by boat
                    for (let i = 0; i < boatData.length; i++) {
                        const boat = boatData[i];
                        for (let j = 0; j < num_rowers; j++) {
                            if (newMultiset[j] === i) {
                                // connect rower to boat
                                connectRowerToBoat(j, i);
                                await delay(200);
                            }
                        }
                    }
                    finishedDrawing = true;
                }

            // Add button to generate a new permutation
            const button = d3.select('#visualization').append('button')
                .text('Generate new assignment')
                .on('click', drawConnections);

            // when the page loads, draw the first permutation
            d3.select(window).on('load', drawConnections);
        }
        drawMain();
    </script>

    <h2>How to use?</h2>
    <p>
        Here is a short video tutorial on how to use the Wolfson Scheduler.
    </p>
    <h2>How does it work?</h2>
    <p>
        The scheduler works by utilizing the power of parallelism.
        For every outing we have a set of boats, and a set of rowers (let's assume that everyone is available for simplicity).
        In the first step, the scheduler enumerates all possible ways to assign rowers to boats per outing:
    </p>
    <div id="fig2" style="margin-top: 10px; display: flex; justify-content: center;"></div>
    </div>
    <script>
        // Here we only draw the permutations of the colors on limited number of circles
        // e.g. 2 red, 1 orange, 1 purple
        async function drawFig2() {
            const width = 800;
            const height = 950;
            const svg = d3.select('#fig2')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            const num_rowers = 5;
            const num_outings = 3;
            const num_comb = 4;
            const boatData = [
                { value: 2, color: 'red' },
                { value: 1, color: 'orange' },
                { value: 1, color: 'purple' },
                { value: 1, color: 'transparent'}
            ];
            
            // Horizontal offsets
            const offsets = [30, 230, 430, 650];



            let highlightBoxes = [];
            let connectors = [];
            const outings = [];
            async function drawOutings(){
                for (let outing_idx = 0; outing_idx < num_outings; outing_idx++) {
                    outings.push([]);
                    offsetX = offsets[outing_idx];
                    outingGroup = svg.append('g')
                        .attr('transform', `translate(${offsetX}, 20)`);
                    for (let comb_idx = 0; comb_idx < num_comb; comb_idx++) {
                        offsetY = comb_idx * 50;
                        const combGroup = outingGroup.append('g')
                            .attr('transform', `translate(0, ${offsetY})`);

                        const permutation = multisetPermutation(boatData.map(d => d.value));
                        // Draw circles
                        combGroup.selectAll('.circle')
                            .data(permutation)
                            .enter().append('circle')
                            .attr('class', 'circle')
                            .attr('cx', (d, i) => i * 35)
                            .attr('cy', 20)
                            .attr('r', 15)
                            .style('stroke', d => boatData[d].color)
                            .style('stroke-width', 2)
                            .style('opacity', 0)
                            .transition()
                            .duration(500)
                            .style('opacity', 1);
                        
                        // Draw a rounded rectangle around the circles
                        const rect = combGroup.append('rect')
                            .attr('x', -20)
                            .attr('y', 0)
                            .attr('rx', 10)
                            .attr('ry', 10)
                            .attr('width', 5 + num_rowers * 35)
                            .attr('height', 40)
                            .style('fill', 'none')
                            .style('stroke', 'gray')
                            .style('stroke-width', 1)
                            .style('opacity', 0)
                            .transition()
                            .duration(500)
                            .style('opacity', 1);

                        
                        
                        outings[outing_idx].push(combGroup);
                        await delay(100);
                    }
                    // At the bottom of the column write the outing number
                    // get the bottom coordinate
                    const textX = outingGroup.node().getBBox().x + outingGroup.node().getBBox().width / 2;
                    const textY = outingGroup.node().getBBox().y + outingGroup.node().getBBox().height + 20;
                    
                    outingGroup.append('text')
                        .attr('x', textX)
                        .attr('y', textY)
                        .text(`Outing ${outing_idx+1}`)
                        .style('font-size', 20)
                        .attr('text-anchor', 'middle')
                        .attr('fill', 'black')
                        .style('opacity', 0)
                        .transition()
                        .duration(500)
                        .style('opacity', 1);

                    // Draw a highlight box that will slide over the combinations
                    const highlightBox = outingGroup.append('rect')
                            .attr('id', `highlightBox${outing_idx}`)
                            .attr('x', -20)
                            .attr('y', 0)
                            .attr('rx', 10)
                            .attr('ry', 10)
                            .attr('width', 5 + num_rowers * 35)
                            .attr('height', 40)
                            .style('fill', 'none')
                            .style('stroke', 'black')
                            .style('stroke-width', 3)
                            .style('opacity', 0);

                    const connector = outingGroup.append('path')
                        .style('stroke', 'black')
                        .style('stroke-width', 3)
                        .style('opacity', 0);
                    
                    highlightBoxes.push(highlightBox);
                    connectors.push(connector);
                    // await delay(1000);
                };
            }
            await drawOutings();


            // In the last column draw a 3D cube of circles
            // with the dimensions of [num_combinations_per_outing, num_combinations_per_outing, num_combinations_per_outing]

            // Generate the scores
            let scores = [];
            for (let i = 0; i < num_comb; i++) {
                for (let j = 0; j < num_comb; j++) {
                    for (let k = 0; k < num_comb; k++) {
                        x = i / num_comb;
                        y = j / num_comb / num_comb;
                        z = k / num_comb / num_comb / num_comb;
                        scores.push(x + y + z);
                    }
                }
            }
            // shuffle the scores
            const origIndices = Array.from(Array(scores.length).keys());
            for (let i = scores.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [scores[i], scores[j]] = [scores[j], scores[i]];
                [origIndices[i], origIndices[j]] = [origIndices[j], origIndices[i]];
            }
            const reshapedScores = [];
            for (let i = 0; i < num_comb; i++) {
                reshapedScores.push([]);
                for (let j = 0; j < num_comb; j++) {
                    reshapedScores[i].push([]);
                    for (let k = 0; k < num_comb; k++) {
                        reshapedScores[i][j].push(scores[i * num_comb * num_comb + j * num_comb + k]);
                    }
                }
            }
            scores = reshapedScores;

            // draw the circles
            const spacingX = 28; // horizontal spacing between circles
            const spacingY = 55; // vertical spacing between circles
            const spacingZ = 10; // the shift for depth (z-axis)
            const scoreCircles = [];
            const cubeGroup = svg.append('g')
                .attr('transform', `translate(${offsets[3]}, 35)`);
            for (let i = 0; i < num_comb; i++) {
                scoreCircles.push([]);
                const depthLattice = cubeGroup.append('g')
                    .attr('transform', `translate(${i*spacingZ}, ${i * spacingZ})`);
                for (let j = 0; j < num_comb; j++) {
                    scoreCircles[i].push([]);
                    for (let k = 0; k < num_comb; k++) {
                        const circle = depthLattice.append('circle')
                            .attr('cx', j * spacingX)
                            .attr('cy', k * spacingY)
                            .attr('r', 10)
                            .style('fill', 'transparent')
                            .style('opacity', 0)
                            .style('stroke', 'gray');
                        scoreCircles[i][j].push(circle);
                    }           
                }
            }

            cubeGroup.selectAll('circle')
                .transition()
                // .duration(1500)
                .style('opacity', 1);

            // await delay(200);
            


            for (let outing_idx=0; outing_idx<num_outings; outing_idx++) {
                const highlightBox = highlightBoxes[outing_idx];
                highlightBox.transition()
                    // .duration(1500)
                    .style('opacity', 1);
            }
            
            // await delay(3000);
            
            function drawEdges() {
                // Calculate the positions of the corner circles
                // Assuming the leftmost, topmost circle is at (0, 0) and `depthShift` is the depth between layers
                const numCircles = num_comb;

                const backTopLeft = [0, 0];
                const backBottomLeft = [0, spacingY * (numCircles - 1)];
                const backTopRight = [spacingX * (numCircles - 1), 0];
                const backBottomRight = [spacingX * (numCircles - 1), spacingY * (numCircles - 1)];

                const depthShift = spacingZ * (numCircles - 1);
                const frontTopLeft = [depthShift, depthShift];
                const frontBottomLeft = [depthShift, spacingY * (numCircles - 1) + depthShift];
                const frontTopRight = [spacingX * (numCircles - 1) + depthShift, depthShift];
                const frontBottomRight = [spacingX * (numCircles - 1) + depthShift, spacingY * (numCircles - 1) + depthShift];

                // Draw the boundary lines of the cube
                function drawBoundaryLine(from, to, dashed = false) {
                    cubeGroup.append('line')
                        .attr('x1', eval(from)[0])
                        .attr('y1', eval(from)[1])
                        .attr('x2', eval(to)[0])
                        .attr('y2', eval(to)[1])
                        .style('stroke', 'gray')
                        .style('stroke-width', 3)
                        .style('stroke-dasharray', dashed ? '5, 5' : 'none');
                }

                // back face
                drawBoundaryLine('backTopLeft', 'backTopRight');
                drawBoundaryLine('backTopLeft', 'backBottomLeft');
                drawBoundaryLine('backBottomLeft', 'backBottomRight', true);
                drawBoundaryLine('backBottomRight', 'backTopRight', true);

                // front face
                drawBoundaryLine('frontTopLeft', 'frontTopRight');
                drawBoundaryLine('frontTopLeft', 'frontBottomLeft');
                drawBoundaryLine('frontBottomLeft', 'frontBottomRight');
                drawBoundaryLine('frontBottomRight', 'frontTopRight');

                // Connecting edges
                drawBoundaryLine('backTopLeft', 'frontTopLeft');
                drawBoundaryLine('backTopRight', 'frontTopRight');
                drawBoundaryLine('backBottomLeft', 'frontBottomLeft');
                drawBoundaryLine('backBottomRight', 'frontBottomRight', true);
            }

            // drawEdges();

            // iterate through all possible combinations with a black 
            // rectangle floating above all the outings
            // and draw a line between the outing and the rectangle

            

            previousCombination = [0, 0, 0];
            function drawCombination(combination) {
                
                for (let outing_idx = 0; outing_idx < num_outings; outing_idx++) {
                    const comb_idx = parseInt(combination[outing_idx]);
                    const outing = outings[outing_idx][comb_idx];
                    highlightBox = highlightBoxes[outing_idx];
                    highlightBox.transition()
                        .duration(100)
                        .style('opacity', 1)
                        .attr('transform', outing.attr('transform'));
                }
                
                // unselect the previous combination
                i = previousCombination[1];
                j = previousCombination[2];
                k = previousCombination[0];
                scoreCircles[i][j][k].style('stroke-width', 1);

                // draw the values of the scores
                i = combination[1];
                j = combination[2];
                k = combination[0];
                scoreCircles[i][j][k].style('stroke', 'black')
                    .style('stroke-width', 3)
                    .style('fill', d3.interpolateGreens(scores[i][j][k]));
                
                previousCombination = combination;
            }

            waitTime = 50;
            for (let i = 0; i < num_comb; i++) {
                for (let j = 0; j < num_comb; j++) {
                    for (let k = 0; k < num_comb; k++) {
                        drawCombination([i, j, k]);
                        await delay(waitTime);
                        waitTime = Math.max(waitTime*0.95, 10);
                    }
                }
            }


            // draw colorbar for the scores
            const numStep = num_comb ** num_outings;
            const colorbar = svg.append('g')
                .attr('transform', `translate(${offsets[3]-20}, 300)`);
            const colorbarWidth = 150;
            const colorbarHeight = 20;
            const colorbarScale = d3.scaleLinear()
                .domain([0, 1])
                .range([0, colorbarWidth]);
            const colorbarAxis = d3.axisBottom(colorbarScale)
                .tickSize(0)
                // just only show Bad and Good
                .tickValues([0, 1])
                .tickFormat(d => d === 0 ? 'Bad' : 'Good')
                .tickPadding(10);
            colorbar.append('g')
                .attr('transform', `translate(0, ${colorbarHeight})`)
                .call(colorbarAxis);
            const colorScale = d3.scaleLinear()
                .domain([0, 1])
                .interpolate(() => d3.interpolateGreens);
            var actualColorbar = colorbar.append("g")
                .attr("class", "colorbar")
                .selectAll("rect")
                .data(d3.range(0, 1, 1/numStep)) // Create a range of values
                .enter().append("rect")
                .attr("x", (d, i) => i * colorbarWidth / numStep) // Position each bar
                .attr("width", colorbarWidth/numStep)
                .attr("height", colorbarHeight)
                .attr("fill", d => colorScale(d))
                .on("mouseover", function(d, idx) {
                    console.log(d, idx);
                    idx = origIndices[idx];
                    i = Math.floor(idx / num_comb / num_comb);
                    j = Math.floor((idx - i * num_comb * num_comb) / num_comb);
                    k = idx - i * num_comb * num_comb - j * num_comb;
                    drawCombination([i, j, k]);
                });
            colorbar.append('text')
                .attr('x', colorbarWidth / 2)
                .attr('y', -5)
                .text('Weekly Schedule score')
                .attr('text-anchor', 'middle')
                .attr('fill', 'black')
                .style('font-size', 20);


            // Once the animation is ready let the user interact with the cube
            // by hovering the mouse on the circles
            for (let i = 0; i < num_comb; i++) {
                for (let j = 0; j < num_comb; j++) {
                    for (let k = 0; k < num_comb; k++) {
                        const circle = scoreCircles[i][j][k];
                        circle.on('mouseover', function() {
                            circle.style('stroke', 'black')
                                .style('stroke-width', 3)
                                .style('fill', d3.interpolateGreens(scores[i][j][k]));
                            drawCombination([k, i, j]);
                        });
                        circle.on('mouseout', function() {
                            circle.style('stroke-width', 1);
                        });
                    }
                }
            }

            for (let outing_idx=0; outing_idx<num_outings; outing_idx++) {
                for (let comb_idx=0; comb_idx<num_comb; comb_idx++) {
                    const combGroup = outings[outing_idx][comb_idx];
                    combGroup.on('mouseover', function() {
                        copyCombination = previousCombination.slice();
                        copyCombination[outing_idx] = comb_idx;
                        drawCombination(copyCombination);
                    });
                    combGroup.on('mouseout', function() {
                        drawCombination(previousCombination);
                    });
                }
            }
            

            
            

        };
        drawFig2();
    </script>
</body>
</html>
